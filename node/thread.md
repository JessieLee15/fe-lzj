# Node：单线程、异步I/O

node最大优势：
1. 底层C/C++（速度）
2. V8引擎（性能）
3. 异步I/O（效率）

## 一、基础概念
### 进程

进程是一种抽象的概念，从来没有统一的标准定义。

>百度百科：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。
> 阮一峰：对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。

### 线程
>百度百科：线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以有很多线程，每条线程并行执行不同的任务。

### CPU与I/O，多线程（可以看看参考文档👇，帮助理解）
1. 他们的工作实际是分开的（不同的物理空间、不同的处理、不同的机制）
2. I/O对CPU的占用实际只有：上下文切换开销（发起调用、调用结果获取）
  * 因此，同步I/O模式下，一个线程遇到I/O：
    1. 发起调用
    2. I/O干活，CPU线程等待I/O（实际CPU啥都没干，当然有休眠等优化策略）
    3. 获得结果继续处理
    4. 1.2.3步骤会封装在一起-线程A，凡是要调用A的地方，就新启一个线程

### 单线程
指的是一个进程只有一个线程（当然是异步I/O）
* 弱点：
  1. 无法利用多核CPU
  2. 出现错误则整个应用退出
  3. 大量计算占用CPU时，阻塞异步I/O的调用（无法发起调用，回调也得不到执行）
优点：
  1. 不需管理线程：线程状态的同步问题
  2. 没有死锁（TODO: 什么是死锁，死锁如何产生）
  3. 没有线程切换的开销

#### NODE的单线程
并非真正意义上的单线程（演示：起一个node服务，查看管理器）
* Node的单线程指的是只是给用于运行用户编写的业务代码（JavaScript）的线程只有一个；内部完成I/O任务的另有线程池
* 一个Node服务（一个进程）实际一般存在7个线程（其实是V8实例，这些其实都是并发执行）
  * 编译执行代码thread（main，我们所谓的单线程）
  * 编译/优化thread
  * 分析器thread
  * 垃圾回收thread

## 二、Node实现异步I/O
### 事件循环
不停取回调函数、执行回调函数的一个循环（实际是取请求对象）
#### 事件
* 浏览器的事件：点击、加载文件. . .
* Node的事件：网络请求、文件I/O、数据库操作. . .
### 如何判断是否还有事件 —— 观察者
* 存在一个或多个观察者（其实是根据事件类型来的）：文件I/O观察者、网络I/O观察者
### 请求对象
实现异步IO的中间产物：实质是一个对象，里面包含了此异步操作的所有信息：JS的入参、当前方法、回调函数（oncomplete_sys）、线程状态、I/O执行结果等等
### I/O线程池
所有的I/O其实是并行运行的？？？

## 三、Node中异步编程（开发）
### 传统
1. 事件发布/订阅模式 [Events模块](https://nodejs.org/dist/latest-v12.x/docs/api/events.html)
  ```javascript
  //数据服务的优化
  var proxy = new events.EventEmitter();
  var status = 'ready';
  var select = function(callback){
    proxy.once('selected', callback);
    if(status === 'ready'){
      status = 'pending';
      db.select('SQL', function(results){
        proxy.emit('selected', results);
        status = 'ready';
      })
    }
  }
  ```
  * seqlize的find是否也有类似机制？【TODO: sequelize.query源码图片】；hook机制理解：参考文章👇，公用组件的公用数据管理

## 四、 Node实现并发多任务

### child_process：是基础API

### cluster：是更深层次的应用

### 浏览器实现多线程
* Web Workers（兼容性）：解决对CPU的利用，减少了UI渲染的阻塞；不能解决UI渲染效率


## NODE异步编程
1. 注意理解计算密集与I/O密集，及取舍：也不是说node不适合计算密集，这个主要取决物理服务器的能力
  * 建议对CPU的耗用不超过10ms，或大计算拆分进行（使用setImmediate()）
    * TODO: 定时器（setTimeout(),setInterval()）、nextTick()、setImmediate()区别分析
    * 总的来说，跟事件循环机制的观察者相关：定时器观察者、idel观察者、I/O观察者、check观察者
    * 定时器观察者有特殊之处，就是时间并不精确（可容忍），原因是每次Tick会检查一次观察者，这就取决于一次Tick的时间

- - 
参考啊：
1. [I/O会一直占用CPU吗](https://www.zhihu.com/question/27734728)
2. [hooks 实现原理](https://www.jianshu.com/p/d41e6b09ef41)
